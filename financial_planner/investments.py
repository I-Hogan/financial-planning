"""Investment account models and portfolio-level coordination."""

from __future__ import annotations

from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Dict, Iterable, Optional, Union

from financial_planner import tax_calculator
from financial_planner.tax_constants import (
    CAPITAL_GAINS_INCLUSION_RATE,
    RRSP_ANNUAL_CONTRIBUTION_LIMIT,
    RRSP_CONTRIBUTION_RATE,
    TFSA_ANNUAL_CONTRIBUTION_LIMIT,
)


def _round_money(amount: float) -> float:
    """Round currency values to two decimal places."""
    return round(amount, 2)


class AssetType(ABC):
    """Return profile for an investment asset."""

    @abstractmethod
    def calculate_returns(self, balance: float) -> "ReturnBreakdown":
        """Calculate returns for the provided balance."""


@dataclass(frozen=True)
class FixedIncomeAsset(AssetType):
    """Fixed income asset with cash-only returns."""

    annual_return_rate: float

    def calculate_returns(self, balance: float) -> "ReturnBreakdown":
        """Return income-only results for a balance."""
        income = _round_money(balance * self.annual_return_rate)
        return ReturnBreakdown(growth=0.0, income=income)


@dataclass(frozen=True)
class GlobalEquityIndexAsset(AssetType):
    """Global equity index asset with growth and income components."""

    annual_growth_rate: float
    annual_income_rate: float

    def calculate_returns(self, balance: float) -> "ReturnBreakdown":
        """Return growth and income results for a balance."""
        growth = _round_money(balance * self.annual_growth_rate)
        income = _round_money(balance * self.annual_income_rate)
        return ReturnBreakdown(growth=growth, income=income)


DEFAULT_ASSET_TYPE = GlobalEquityIndexAsset(annual_growth_rate=0.0, annual_income_rate=0.0)


@dataclass(frozen=True)
class ReturnBreakdown:
    """Split investment returns into growth and income components."""

    growth: float
    income: float

    @property
    def total(self) -> float:
        """Return the combined growth and income."""
        return _round_money(self.growth + self.income)


@dataclass(frozen=True)
class TaxImpact:
    """Summary of taxable income and deductions generated by an account."""

    taxable_income: float = 0.0
    deduction: float = 0.0


@dataclass(frozen=True)
class AccountYearSummary:
    """Results for a single account after incrementing a year."""

    returns: ReturnBreakdown
    tax_impact: TaxImpact


@dataclass(frozen=True)
class InvestmentYearSummary:
    """Aggregate tax impact across earned income and investment accounts."""

    taxable_income: float
    deductions: float
    net_taxable_income: float
    tax_owed: float


@dataclass(frozen=True)
class InvestmentYearResult:
    """Annual results for the investment portfolio."""

    tax_summary: InvestmentYearSummary
    account_summaries: Dict[str, AccountYearSummary]


class InvestmentAccount(ABC):
    """Abstract investment account model."""

    def __init__(
        self,
        *,
        balance: float = 0.0,
        asset_type: Optional[AssetType] = None,
        contribution_room: Optional[float] = None,
    ) -> None:
        self.balance = _round_money(balance)
        self.year_start_balance = self.balance
        self.asset_type = asset_type or DEFAULT_ASSET_TYPE
        self.contribution_room = (
            None if contribution_room is None else _round_money(contribution_room)
        )
        self.deposits = 0.0
        self.withdrawals = 0.0

    def deposit(self, amount: float) -> None:
        """Add money to the account."""
        self._validate_positive_amount(amount)
        if amount > self.available_room():
            raise ValueError("Deposit exceeds available contribution room.")
        self.balance = _round_money(self.balance + amount)
        self.deposits = _round_money(self.deposits + amount)
        if self.contribution_room is not None:
            self.contribution_room = _round_money(self.contribution_room - amount)

    def withdrawal(self, amount: float) -> None:
        """Withdraw money from the account."""
        self._validate_positive_amount(amount)
        if amount > self.balance:
            raise ValueError("Withdrawal exceeds available balance.")
        self.balance = _round_money(self.balance - amount)
        self.withdrawals = _round_money(self.withdrawals + amount)

    def calculate_returns(self) -> ReturnBreakdown:
        """Calculate account returns for the year."""
        return self.asset_type.calculate_returns(self.balance)

    def update_account(self, returns: ReturnBreakdown) -> None:
        """Apply returns to the account balance."""
        self.balance = _round_money(self.balance + returns.total)

    @abstractmethod
    def calculate_tax(self, returns: ReturnBreakdown) -> TaxImpact:
        """Calculate tax impact based on deposits, withdrawals, and returns."""

    def increment_year(
        self,
        *,
        previous_year_income: Optional[float] = None,
        contribution_limit_adjustment: float = 1.0,
    ) -> AccountYearSummary:
        """Advance the account by one year and reset annual trackers."""
        if contribution_limit_adjustment <= 0:
            raise ValueError("Inflation adjustment must be positive.")
        returns = self.calculate_returns()
        self.update_account(returns)
        tax_impact = self.calculate_tax(returns)
        self.year_start_balance = self.balance
        self._add_contribution_room(previous_year_income, contribution_limit_adjustment)
        self.deposits = 0.0
        self.withdrawals = 0.0
        self._reset_year_tracking()
        return AccountYearSummary(returns=returns, tax_impact=tax_impact)

    def available_room(self) -> float:
        """Return available contribution room for the current year."""
        if self.contribution_room is None:
            return float("inf")
        return max(0.0, _round_money(self.contribution_room))

    def _reset_year_tracking(self) -> None:
        """Reset any subclass-specific tracking at year end."""

    def _add_contribution_room(
        self, previous_year_income: Optional[float], contribution_limit_adjustment: float
    ) -> None:
        """Update contribution room for the next year if applicable."""
        _ = previous_year_income
        _ = contribution_limit_adjustment

    @staticmethod
    def _validate_positive_amount(amount: float) -> None:
        if amount < 0:
            raise ValueError("Amount must be non-negative.")


class TFSA(InvestmentAccount):
    """Tax-free savings account."""

    def __init__(
        self,
        *,
        balance: float = 0.0,
        asset_type: Optional[AssetType] = None,
        initial_contribution_room: float = TFSA_ANNUAL_CONTRIBUTION_LIMIT,
    ) -> None:
        super().__init__(
            balance=balance,
            asset_type=asset_type,
            contribution_room=initial_contribution_room,
        )

    def calculate_tax(self, returns: ReturnBreakdown) -> TaxImpact:
        return TaxImpact()

    def _add_contribution_room(
        self, previous_year_income: Optional[float], contribution_limit_adjustment: float
    ) -> None:
        """Increase TFSA contribution room by the annual limit."""
        if self.contribution_room is None:
            self.contribution_room = 0.0
        limit = _round_money(TFSA_ANNUAL_CONTRIBUTION_LIMIT * contribution_limit_adjustment)
        self.contribution_room = _round_money(self.contribution_room + limit + self.withdrawals)


class RRSP(InvestmentAccount):
    """Registered retirement savings plan."""

    def __init__(
        self,
        *,
        balance: float = 0.0,
        asset_type: Optional[AssetType] = None,
        initial_contribution_room: float = 0.0,
    ) -> None:
        super().__init__(
            balance=balance,
            asset_type=asset_type,
            contribution_room=initial_contribution_room,
        )

    def calculate_tax(self, returns: ReturnBreakdown) -> TaxImpact:
        return TaxImpact(
            taxable_income=_round_money(self.withdrawals),
            deduction=_round_money(self.deposits),
        )

    def _add_contribution_room(
        self, previous_year_income: Optional[float], contribution_limit_adjustment: float
    ) -> None:
        """Increase RRSP contribution room using prior-year income."""
        if previous_year_income is None:
            previous_year_income = 0.0
        limit = _round_money(RRSP_ANNUAL_CONTRIBUTION_LIMIT * contribution_limit_adjustment)
        new_room = min(previous_year_income * RRSP_CONTRIBUTION_RATE, limit)
        if self.contribution_room is None:
            self.contribution_room = 0.0
        self.contribution_room = _round_money(self.contribution_room + new_room)


class Unregistered(InvestmentAccount):
    """Taxable investment account."""

    def __init__(
        self,
        *,
        balance: float = 0.0,
        asset_type: Optional[AssetType] = None,
        contribution_room: Optional[float] = None,
        cost_basis: Optional[float] = None,
    ) -> None:
        super().__init__(
            balance=balance,
            asset_type=asset_type,
            contribution_room=contribution_room,
        )
        self.cost_basis = _round_money(self.balance if cost_basis is None else cost_basis)
        self.realized_capital_gains = 0.0

    def deposit(self, amount: float) -> None:
        super().deposit(amount)
        self.cost_basis = _round_money(self.cost_basis + amount)

    def withdrawal(self, amount: float) -> None:
        self._validate_positive_amount(amount)
        if amount > self.balance:
            raise ValueError("Withdrawal exceeds available balance.")
        if self.balance == 0:
            raise ValueError("Cannot withdraw from an empty account.")
        proportion = amount / self.balance
        cost_basis_reduction = _round_money(self.cost_basis * proportion)
        realized_gain = _round_money(amount - cost_basis_reduction)
        self.cost_basis = _round_money(self.cost_basis - cost_basis_reduction)
        self.realized_capital_gains = _round_money(self.realized_capital_gains + realized_gain)
        super().withdrawal(amount)

    def update_account(self, returns: ReturnBreakdown) -> None:
        super().update_account(returns)
        self.cost_basis = _round_money(self.cost_basis + returns.income)

    def calculate_tax(self, returns: ReturnBreakdown) -> TaxImpact:
        taxable_capital_gains = max(0.0, self.realized_capital_gains)
        taxable_income = returns.income + (taxable_capital_gains * CAPITAL_GAINS_INCLUSION_RATE)
        return TaxImpact(taxable_income=_round_money(taxable_income))

    def _reset_year_tracking(self) -> None:
        self.realized_capital_gains = 0.0


AccountSelector = Union[str, InvestmentAccount]


class Investments:
    """Collection of investment accounts with portfolio-level helpers."""

    def __init__(
        self,
        *,
        tfsa: Optional[TFSA] = None,
        rrsp: Optional[RRSP] = None,
        unregistered: Optional[Unregistered] = None,
    ) -> None:
        self.tfsa = tfsa or TFSA()
        self.rrsp = rrsp or RRSP()
        self.unregistered = unregistered or Unregistered()

    def deposit(self, amount: float, account_order: Iterable[AccountSelector]) -> float:
        """Deposit funds using the provided account order, returning leftovers."""
        if amount < 0:
            raise ValueError("Amount must be non-negative.")
        remaining = _round_money(amount)
        planned_deposits = []
        planned_used: Dict[InvestmentAccount, float] = {}
        for entry in account_order:
            if remaining <= 0:
                break
            account = self._resolve_account(entry)
            available = account.available_room() - planned_used.get(account, 0.0)
            if available <= 0:
                continue
            deposit_amount = min(remaining, available)
            planned_deposits.append((account, deposit_amount))
            planned_used[account] = planned_used.get(account, 0.0) + deposit_amount
            remaining = _round_money(remaining - deposit_amount)
        if remaining > 0:
            raise ValueError("Deposit exceeds available contribution room.")
        for account, deposit_amount in planned_deposits:
            account.deposit(deposit_amount)
        return remaining

    def increment_year(
        self,
        *,
        annual_income: float = 0.0,
        inflation_adjustment: float = 1.0,
        next_year_inflation_adjustment: Optional[float] = None,
    ) -> InvestmentYearResult:
        """Increment the year for all accounts and return tax impacts."""
        if annual_income < 0:
            raise ValueError("Annual income cannot be negative.")
        if inflation_adjustment <= 0:
            raise ValueError("Inflation adjustment must be positive.")
        if next_year_inflation_adjustment is None:
            next_year_inflation_adjustment = inflation_adjustment
        if next_year_inflation_adjustment <= 0:
            raise ValueError("Inflation adjustment must be positive.")
        account_summaries: Dict[str, AccountYearSummary] = {}
        taxable_income = _round_money(annual_income)
        deductions = 0.0
        for name, account in self._accounts_by_name().items():
            summary = account.increment_year(
                previous_year_income=annual_income,
                contribution_limit_adjustment=next_year_inflation_adjustment,
            )
            account_summaries[name] = summary
            taxable_income += summary.tax_impact.taxable_income
            deductions += summary.tax_impact.deduction
        taxable_income = _round_money(taxable_income)
        deductions = _round_money(deductions)
        net_taxable_income = _round_money(max(0.0, taxable_income - deductions))
        tax_owed = (
            tax_calculator.calculate_ontario_combined_income_tax(
                net_taxable_income,
                inflation_adjustment=inflation_adjustment,
            )
            if net_taxable_income > 0
            else 0.0
        )
        tax_summary = InvestmentYearSummary(
            taxable_income=taxable_income,
            deductions=deductions,
            net_taxable_income=net_taxable_income,
            tax_owed=_round_money(tax_owed),
        )
        return InvestmentYearResult(tax_summary=tax_summary, account_summaries=account_summaries)

    def total_value(
        self, *, inflation_adjustment: float = 1.0, liquidation_years: int = 1
    ) -> float:
        """Return the after-tax value if all accounts were liquidated."""
        if inflation_adjustment <= 0:
            raise ValueError("Inflation adjustment must be positive.")
        if liquidation_years <= 0:
            raise ValueError("Liquidation years must be positive.")
        total_balance = _round_money(
            self.tfsa.balance + self.rrsp.balance + self.unregistered.balance
        )
        tax_owed = self._estimate_liquidation_tax(
            inflation_adjustment=inflation_adjustment,
            liquidation_years=liquidation_years,
        )
        return _round_money(total_balance - tax_owed)

    def _estimate_liquidation_tax(
        self, *, inflation_adjustment: float, liquidation_years: int
    ) -> float:
        if liquidation_years == 1:
            return self._liquidation_tax_single_year(inflation_adjustment)
        return self._liquidation_tax_spread_years(
            inflation_adjustment=inflation_adjustment,
            liquidation_years=liquidation_years,
        )

    def _liquidation_tax_single_year(self, inflation_adjustment: float) -> float:
        rrsp_balance = self.rrsp.balance
        unregistered_gain = _round_money(self.unregistered.balance - self.unregistered.cost_basis)
        taxable_unregistered_gain = max(0.0, unregistered_gain) * CAPITAL_GAINS_INCLUSION_RATE
        taxable_income = _round_money(rrsp_balance + taxable_unregistered_gain)
        if taxable_income <= 0:
            return 0.0
        return _round_money(
            tax_calculator.calculate_ontario_combined_income_tax(
                taxable_income, inflation_adjustment=inflation_adjustment
            )
        )

    def _liquidation_tax_spread_years(
        self, *, inflation_adjustment: float, liquidation_years: int
    ) -> float:
        remaining_rrsp = self.rrsp.balance
        remaining_unregistered = self.unregistered.balance
        remaining_cost_basis = self.unregistered.cost_basis
        total_tax = 0.0

        for years_left in range(liquidation_years, 0, -1):
            rrsp_withdrawal = _round_money(remaining_rrsp / years_left)
            realized_gain, remaining_unregistered, remaining_cost_basis = (
                self._apply_unregistered_withdrawal(
                    remaining_unregistered, remaining_cost_basis, years_left
                )
            )

            taxable_unregistered_gain = max(0.0, realized_gain) * CAPITAL_GAINS_INCLUSION_RATE
            taxable_income = _round_money(rrsp_withdrawal + taxable_unregistered_gain)
            if taxable_income > 0:
                tax = tax_calculator.calculate_ontario_combined_income_tax(
                    taxable_income, inflation_adjustment=inflation_adjustment
                )
                total_tax = _round_money(total_tax + tax)
            remaining_rrsp = _round_money(remaining_rrsp - rrsp_withdrawal)

        return total_tax

    def _apply_unregistered_withdrawal(
        self, remaining_unregistered: float, remaining_cost_basis: float, years_left: int
    ) -> tuple[float, float, float]:
        unregistered_withdrawal = _round_money(remaining_unregistered / years_left)
        if remaining_unregistered <= 0 or unregistered_withdrawal <= 0:
            return 0.0, remaining_unregistered, remaining_cost_basis
        proportion = unregistered_withdrawal / remaining_unregistered
        cost_basis_reduction = _round_money(remaining_cost_basis * proportion)
        realized_gain = _round_money(unregistered_withdrawal - cost_basis_reduction)
        remaining_cost_basis = _round_money(remaining_cost_basis - cost_basis_reduction)
        remaining_unregistered = _round_money(remaining_unregistered - unregistered_withdrawal)
        return realized_gain, remaining_unregistered, remaining_cost_basis

    def _accounts_by_name(self) -> Dict[str, InvestmentAccount]:
        return {"tfsa": self.tfsa, "rrsp": self.rrsp, "unregistered": self.unregistered}

    def _resolve_account(self, account: AccountSelector) -> InvestmentAccount:
        if isinstance(account, InvestmentAccount):
            return account
        if isinstance(account, str):
            key = account.lower()
            accounts = self._accounts_by_name()
            if key not in accounts:
                raise ValueError(f"Unknown account '{account}'.")
            return accounts[key]
        raise TypeError("Account selector must be a name or InvestmentAccount instance.")
